1. Mysterious Name：意义不明的代码元素命名
2. Dupicated Code：重复代码；有不同类型的代码重复，不要一股脑都提取到一个函数里头
3. Long Function：使用良好命名的小函数，使得你的代码能够轻易通过bfs方式阅读
4. Long Parameter List：形参列表过长
5. Global Data：全局的生命期导致全局变量的值难以确定，极易出bug；个人理解：全局的元素最好是只读或者无状态的
6. Mutable Data：要更新一个数据结构，就创建一个副本并更新这个副本，原数据保持不变
7. Divergent Change：如果一个模块随着修改而逐渐承担了若干个上下文的职责，则需要考虑是否需要将这些已经在处理不同方向逻辑的代码各自搬到一个独立的上下文中
8. Shotgun Surgery：一个修改导致了其他若干个地方的连带改动
9. Feature Envy：如果某个模块过于频繁地调用另一个模块的数据，则需要考虑是否应该将这两个模块整合到一起
10. Data Clumps：如果若干个数据经常一起出现，并且彼此之间关系紧密，可考虑将它们提取到一个类中，并且为这个类赋予实用的含义
11. Primitive Obsession：一些有特殊意义的”基本类型“，其实应该创建一个类来描述并定义其行为，例如钱、坐标、范围等
12. Repeated Switches：如果想在switch语句中加入一个新的分支，你需要修改所有的switch语句
13. Loops：尽量用管道取代循环，更明晰
14. Lazy Element：如果一个额外的结构并没有提升代码的可理解性或可维护性，去掉，不要矫枉过正
15. Speculative Generality：如果有一个元素只是为了未来的虚无缥缈的通用性而存在，去掉
16. Temporary Field：为了某种特定情况诞生的字段，应当将这个字段与相关行为收拢到一处
17. Message Chains：用户向对象A请求对象B，然后再向对象B请求对象C，应当使用委托方式进行优化
18. Middle Man：使用委托实现封装性，将外部访问收归一处
19. Insider Trading：如果两个模块经常交换数据，可以将这些共用的数据放在同一个管理良好的地方，或者使用委托模式
20. Large Class：如果一个类类型过大，字段太多，应当将紧密耦合的字段提炼到新的类中
21. Alternative Classes with Different Interfaces：作用相似的类，应当使其实现相同的接口，并将重复的代码提取到超类中
22. Data Class：其实就是Java Bean的规范
23. Refused Bequest：如果一个子类只需要超类的部分成员，说明继承体系出现问题；传统方法是创建一个子类的兄弟类将超类中不需要继承的东西迁移到兄弟类中；如果子类压根不支持超类的接口，则应当消除继承关系；大多数情况下如果子类只是拒绝一部分成员，其实无需过分担心
24. Comments：好代码自带注释，如果有写注释的冲动，先试试看重构；注释应当关注某段代码的编写动机，或者在没有把握的时候进行说明